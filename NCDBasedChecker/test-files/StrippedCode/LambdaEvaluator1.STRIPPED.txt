package main . lisp . evaluator . basic ; import java . util . ArrayList ; import main . lisp . evaluator . Environment ; import main . lisp . evaluator . Evaluator ; import main . lisp . evaluator . function . LambdaFactory ; import main . lisp . parser . terms . IdentifierAtom ; import main . lisp . parser . terms . IdentifierAtomFactory ; import main . lisp . parser . terms . NilAtom ; import main . lisp . parser . terms . SExpression ; import main . lisp . scanner . tokens . StringToken ; import main . lisp . scanner . tokens . Token ; import main . lisp . scanner . tokens . TokenFactory ; import main . lisp . scanner . tokens . TokenType ; public class LambdaEvaluator implements Evaluator { @ Override public SExpression eval ( SExpression expr , Environment environment ) { ArrayList < SExpression > listOfParams = new ArrayList < SExpression > ( ) ; IdentifierAtom [ ] nameOfArgs = null ; SExpression bodyExpr = null ; expr = expr . getTail ( ) ; if ( expr . isNIL ( ) ) { throw new IllegalStateException ( "Missing arguments for operator 'lambda'" ) ; } bodyExpr = expr . getTail ( ) ; SExpression params = expr . getHead ( ) ; if ( ! ( params . isNIL ( ) ) ) { listOfParams . add ( params . getHead ( ) ) ; while ( ! ( params . getTail ( ) . isNIL ( ) ) ) { params = params . getTail ( ) ; listOfParams . add ( params . getHead ( ) ) ; } } nameOfArgs = new IdentifierAtom [ listOfParams . size ( ) ] ; TokenFactory . setTokenClass ( TokenType . STRING , StringToken . class ) ; for ( int i = 0 ; i < listOfParams . size ( ) ; i ++ ) { Token token = TokenFactory . newInstance ( TokenType . STRING , listOfParams . get ( i ) . toString ( ) ) ; nameOfArgs [ i ] = IdentifierAtomFactory . newInstance ( token ) ; } return LambdaFactory . newInstance ( nameOfArgs , bodyExpr ) ; } } <EOF> 